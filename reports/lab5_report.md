# Topic: Parser & Building an Abstract Syntax Tree

### Course: Formal Languages & Finite Automata
### Author: Nastas Corneliu

----

## Theory

## Parsers

&nbsp &nbsp &nbsp Parsing is the process of analyzing a string of symbols, typically based on the rules of a formal grammar. In the context of formal languages and finite automata, parsing refers to the process of determining if a string can be generated by a formal language and identifying its structure according to the grammar. 

&nbsp &nbsp &nbsp In practice, parsing can involve using a finite automaton to examine an input string symbol by symbol, transitioning between states according to a function. If the automaton ends in an accepting state, the string is recognized as belonging to the language, and its structure can be identified based on the rules of the formal language.

    
## Types of Parsers

Parsers can be categorized into two types: *top-down parsers* and *bottom-up parsers*.

### 1. Top-Down Parsers

Top-down parsers start with the highest level of abstraction (typically the start symbol in a grammar) and work their way down to the individual symbols in the string.

#### 1.1 Recursive Descent Parsing
- This is a kind of top-down parsing built from a set of mutually recursive procedures where each procedure usually implements one production of the grammar.

#### 1.2 Predictive Parsing
- This is a form of recursive descent parser that doesn't require backtracking. It involves adding a lookahead to the parser or making sure the grammar is a LL(1) grammar.

#### 1.3 LL Parsing
- A form of predictive parsing where L stands for left-to-right scanning of the input and the second L for leftmost derivation. It is often implemented non-recursively, with an explicit stack data structure.

### 2. Bottom-Up Parsers

Bottom-up parsers start with the individual symbols of the string and work their way up to the highest level of abstraction.

#### 2.1 Shift-Reduce Parsing
- A type of bottom-up parsing where symbols are shifted from an input buffer onto a stack until a rule can be applied, at which point a reduction is performed.

#### 2.2 LR Parsing
- A type of shift-reduce parsing that reads input from Left-to-right and produces a Rightmost derivation. 

#### 2.3 SLR, LALR, and Canonical LR Parsing
- These are specific types of LR parsers, each with different abilities and complexities.

The choice between top-down and bottom-up parsing usually depends on the specific requirements of the situation, such as the complexity of the grammar, the need for error detection and recovery, and efficiency considerations.


## Abstract Syntax Tree (AST)

An Abstract Syntax Tree (AST) is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code.

The syntax is 'abstract' in not representing every detail appearing in the real syntax. For instance, grouping parentheses are implicit in the tree structure, and a syntactic construct like an `if` condition statement is represented as a single node with separate children that, syntactically, represent the condition, the then-clause, and the else-clause.

### Uses of AST

1. **Code Analysis**: ASTs can be used to extract information (metrics) from the source code.
2. **Code Transformation and Optimization**: ASTs are used in compilers to transform the source code into a more efficient or optimized form.
3. **Code Generation**: They are also used for generating code in a different language (transpiling).
4. **Syntax Highlighting**: They can be used in text editors and IDEs for providing syntax highlighting or for providing code suggestions.


## Objectives:
1. Get familiar with parsing, what it is and how it can be programmed [1].
2. Get familiar with the concept of AST [2].
3. In addition to what has been done in the 3rd lab work do the following:
   1. In case you didn't have a type that denotes the possible types of tokens you need to:
      1. Have a type __*TokenType*__ (like an enum) that can be used in the lexical analysis to categorize the tokens. 
      2. Please use regular expressions to identify the type of the token.
   2. Implement the necessary data structures for an AST that could be used for the text you have processed in the 3rd lab work.
   3. Implement a simple parser program that could extract the syntactic information from the input text.


## Implementation description:
1. In my simplified version of the AST I have the following classes: *PlaceDeclarationNode*, *AssignmentNode* which basically hold the necessary information about specific nodes that are required in the AST tree.

```python
class PlaceDeclarationNode:
    def __init__(self, place_name):
        self.place_name = place_name

class AssignmentNode:
    def __init__(self, place_name, attribute, value):
        self.place_name = place_name
        self.attribute = attribute
        self.value = value
```

2. **Parser** this class operated by taking a token list generated by the *Tokenizer* class implemented in laboratory no.3 and attempts to make some sense of them.

   In this class we have several methods which we are going to break down.

   1. __init__ : This is the constructor method of the Parser class. Initializes the parser with a list of tokens, sets the current cursor position and current_token to None.
   ```python
       def __init__(self, tokens):
        self.tokens = tokens
        self.pos = -1
        self.current_token = None
        self.next()
   ```
   2. **next** : This method increments the current position and updates the current token with the new token at the current position. If the end of the tokens list is reached, it sets the current token to None.
   ```python
    def next(self):
        self.pos += 1
        self.current_token = self.tokens[self.pos] if self.pos < len(self.tokens) else None
   ```
   3. **parse** : This is the method that starts the parsing process. It returns a list of nodes, each representing a construct in the language. In this case, it can be a sequence of place declarations and assignments.
   ```python
        nodes = []
        print(self.current_token)
        while self.current_token is not None:
            if self.current_token.type == "PLACE":
                nodes.append(self.parse_place_declaration())
            else:
                nodes.append(self.parse_assignment())
        return nodes
   ```
   4. **parse_place_declaration** : This method is responsible for parsing a place declaration. It creates and returns a `PlaceDeclarationNode`.
      ```python
        self.next()  # consume the "PLACE" token
        place_name = self.current_token.literal
        self.next()  # consume the "IDENT" token
        if self.current_token.type != ';':
            raise Exception("Invalid Syntax, expected ';'")

        self.next()  # consume the ";" token
        return PlaceDeclarationNode(place_name)
      ```



   5. **parse_assignment** : This method is responsible for parsing an assignment. It creates and returns an `AssignmentNode`.
      ```python
        place_name = self.current_token.literal
        self.next()  # consume the "IDENT" token
        if self.current_token.type != '.':
            raise Exception("Invalid Syntax, expected '.'")

        self.next()  # consume the "." token
        attribute = self.current_token.literal
        self.next()  # consume the "IDENT" token
        if self.current_token.type != '=':
            raise Exception("Invalid Syntax, expected '='")

        self.next()  # consume the "=" token
        value = self.current_token.literal
        self.next()  # consume the "INT" token
        if self.current_token.type != ';':
            raise Exception("Invalid Syntax, expected ';'")

        self.next()  # consume the ";" token
        return AssignmentNode(place_name, attribute, value)
      ```
The parser goes through the tokens one at a time, starting from the beginning, and based on the current token it decides which parse method to call. It constructs an AST node for each construct it encounters, and throws an exception if it encounters a token that it doesn't expect.

### Testing
```python
from ast import Parser, PlaceDeclarationNode, AssignmentNode
from tokenizer import Tokenizer
from tokens import EOF

input: str = """
    place p1;
    p1.amm = 10;
"""
tokenizer = Tokenizer(input)
tokens: list = []
token = tokenizer.next_token()
while token.type is not EOF:
    tokens.append(token)
    token = tokenizer.next_token()

p = Parser(tokens)
tree = p.parse()

for node in tree:
    if isinstance(node, PlaceDeclarationNode):
        print(f"Place declared: {node.place_name}")
    elif isinstance(node, AssignmentNode):
        print(f"Assignment: {node.place_name}.{node.attribute} = {node.value}")
```
Result: 
```
Place declared: p1
Assignment: p1.amm = 10
```


## Conclusion
During this laboratory work I've managed to implement a simple Parser class that parses a small piece of my PBL project, while this implementation have lots of ways to be improved it does parse simple snippets, what could have been done better is error handling and more complex delcarations / assignments. Parsing is a fundamental aspect of programming and it is central to the process of translating and executing code, using the information given by my `Parser` implementation I can now "transpile" this into some Python code which is way easier.


## References:
[1] [Parsing Wiki](https://en.wikipedia.org/wiki/Parsing)

[2] [Abstract Syntax Tree Wiki](https://en.wikipedia.org/wiki/Abstract_syntax_tree)
 